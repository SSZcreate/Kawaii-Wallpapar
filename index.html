<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Interactive Viewer - High Quality Lighting</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* èƒŒæ™¯ã‚’å°‘ã—è½ã¡ç€ã„ãŸè‰²ã«ã—ã¦ã€ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã‚’ç›®ç«‹ãŸã›ã‚‹ */
            background-color: #ffecd2;
            background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #drop-zone-msg {
            display: none;
            background: rgba(255, 255, 255, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 3px dashed #aaa;
            text-align: center;
            color: #555;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #drop-zone-msg:hover {
            background: rgba(255, 255, 255, 1.0);
            border-color: #88ccff;
            transform: scale(1.05);
        }

        #message-box {
            position: absolute;
            top: 15%;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            font-size: 18px;
            font-weight: bold;
            color: #333;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
            white-space: nowrap;
            pointer-events: none;
        }
        #message-box::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.95) transparent;
            display: block;
            width: 0;
        }

        #loading {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(0,0,0,0.5);
            font-size: 12px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <div id="message-box">ã“ã‚“ã«ã¡ã¯ï¼</div>
        
        <!-- File Input (Hidden) -->
        <input type="file" id="file-input" accept=".vrm" style="display: none;">
        
        <div id="drop-zone-msg">
            <div style="font-size: 40px; margin-bottom: 10px;">ğŸ“‚</div>
            èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼<br>
            ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
        </div>
    </div>

    <div id="loading">Loading Sample Model...</div>
    <div id="controls">Mouse: Look / Click: Jump / Drag & Drop: Change VRM</div>

    <!-- Import Maps for Three.js and VRM -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
                "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.3.0/lib/three-vrm.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { VRMLoaderPlugin, VRMUtils, VRMHumanBoneName } from '@pixiv/three-vrm';

        // --- è¨­å®š ---
        const CONFIG = {
            waveInterval: 8000,
            blinkInterval: 3000,
            // ãƒ­ãƒ¼ã‚«ãƒ«ã®VRMãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            sampleUrl: './AliciaSolid.vrm',
            // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ï¼ˆMixamoã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
            walkAnimationUrl: './walk.fbx', // ã¾ãŸã¯ './walk.glb'
            // å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            idleAnimationUrl: './idle.fbx', // å¾…æ©Ÿãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
            // ç§»å‹•ç¯„å›²ã®è¨­å®šï¼ˆã‚«ãƒ¡ãƒ©ã‹ã‚‰è¦‹ãˆã‚‹ç¯„å›²å†…ã«åˆ¶é™ï¼‰
            walkAreaSize: { x: 2, z: 2 },
            walkSpeed: 0.8,
            idleTimeMin: 2000,  // åœæ­¢æ™‚é–“ã®æœ€å°å€¤ (ms)
            idleTimeMax: 5000   // åœæ­¢æ™‚é–“ã®æœ€å¤§å€¤ (ms)
        };

        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let scene, camera, renderer;
        let currentVrm = null;
        let clock = new THREE.Clock();
        
        let mouse = new THREE.Vector2();
        let lookAtTarget = new THREE.Object3D(); 
        
        let isWaving = false;
        
        // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£
        let mixer = null;
        let walkAction = null;
        let idleAction = null;
        let currentAction = null;
        
        // ç§»å‹•åˆ¶å¾¡
        let isWalking = false;
        let targetPosition = new THREE.Vector3();
        let currentPosition = new THREE.Vector3();
        let moveDirection = new THREE.Vector3();
        let rotationTarget = 0;
        
        // Root Motionç”¨
        let lastHipsPosition = new THREE.Vector3();
        let rootMotionDelta = new THREE.Vector3();
        
        function init() {
            // ã‚·ãƒ¼ãƒ³è¨­å®š
            scene = new THREE.Scene();
            scene.add(lookAtTarget); 

            // ã‚«ãƒ¡ãƒ©è¨­å®š
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 20);
            camera.position.set(0, 1.4, 3.0); 

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š (é«˜ç”»è³ªåŒ–)
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            // â˜… ãƒˆãƒ¼ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°ã®è¨­å®šï¼ˆè‰²ã‚’é®®ã‚„ã‹ã«ã€ç™½é£›ã³ã‚’æŠ‘ãˆã‚‹ï¼‰
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // å½±ã®è¨­å®šã‚’æœ‰åŠ¹åŒ–
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.SoftShadowMap;

            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- â˜… ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°è¨­å®š (ã‚¹ã‚¿ã‚¸ã‚ªé¢¨) ---
            createStudioLighting();

            // ã‚°ãƒªãƒƒãƒ‰ï¼ˆåºŠï¼‰
            const gridHelper = new THREE.GridHelper(10, 10, 0xffffff, 0xffffff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mousedown', onMouseDown, false);
            
            setupDragAndDrop();

            // ãƒ«ãƒ¼ãƒ—é–‹å§‹
            animate();
            
            scheduleBlink();
            setInterval(triggerWave, CONFIG.waveInterval);

            // åˆæœŸãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
            loadVRM(CONFIG.sampleUrl);
        }

        // ã‚¹ã‚¿ã‚¸ã‚ªãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createStudioLighting() {
            // 1. ç’°å¢ƒå…‰ (å…¨ä½“ã‚’æŸ”ã‚‰ã‹ãç…§ã‚‰ã™ãƒ™ãƒ¼ã‚¹)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // 2. ãƒ¡ã‚¤ãƒ³ãƒ©ã‚¤ãƒˆ (Key Light) - æ–œã‚å‰ã‹ã‚‰å¼·ãç…§ã‚‰ã™
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(2.0, 2.0, 1.0);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048; // å½±ã‚’ç¶ºéº—ã«
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);

            // 3. ãƒ•ã‚£ãƒ«ãƒ©ã‚¤ãƒˆ (Fill Light) - å½±ã«ãªã‚‹éƒ¨åˆ†ã‚’å°‘ã—é’ã¿ãŒã‹ã£ãŸå…‰ã§å’Œã‚‰ã’ã‚‹
            const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.5);
            fillLight.position.set(-1.0, 1.0, 1.0);
            scene.add(fillLight);

            // 4. ãƒªãƒ ãƒ©ã‚¤ãƒˆ (Rim Light) - èƒŒå¾Œã‹ã‚‰è¼ªéƒ­ã‚’å…‰ã‚‰ã›ã‚‹ï¼ˆé‡è¦ï¼ï¼‰
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’èƒŒæ™¯ã‹ã‚‰æµ®ãä¸ŠãŒã‚‰ã›ã‚‹åŠ¹æœ
            const rimLight = new THREE.SpotLight(0xffeeb1, 2.0); // å°‘ã—æš–è‰²ç³»ã§å¼·ã
            rimLight.position.set(0, 2.0, -2.0);
            rimLight.lookAt(0, 1.0, 0);
            scene.add(rimLight);
        }

        // --- VRMèª­ã¿è¾¼ã¿å‡¦ç† ---
        function loadVRM(url) {
            const loader = new GLTFLoader();
            
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            document.getElementById('loading').style.display = 'block';
            document.getElementById('drop-zone-msg').style.display = 'none';

            loader.load(
                url,
                (gltf) => {
                    const vrm = gltf.userData.vrm;

                    if (currentVrm) {
                        scene.remove(currentVrm.scene);
                        VRMUtils.deepDispose(currentVrm.scene);
                    }

                    currentVrm = vrm;
                    scene.add(vrm.scene);

                    // å½±ã‚’è½ã¨ã™è¨­å®š
                    vrm.scene.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                            // åŠé€æ˜æç”»ã®é †åºå•é¡Œã‚’è»½æ¸›
                            if (obj.material.transparent) {
                                obj.renderOrder = 1; 
                            }
                        }
                    });

                    VRMUtils.rotateVRM0(vrm); 
                    
                    camera.position.set(0, 1.3, 2.5);
                    camera.lookAt(0, 1.0, 0); 

                    vrm.lookAt.target = lookAtTarget;
                    
                    // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èª­ã¿è¾¼ã‚€
                    loadWalkAnimation();
                    
                    console.log("VRM Loaded");
                    document.getElementById('loading').style.display = 'none';
                    showMessage("ã‚ˆã‚ã—ãã­ï¼");
                    setTimeout(hideMessage, 3000);
                    
                    // æ­©è¡Œé–‹å§‹ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
                    setTimeout(startWandering, 3000);
                },
                (progress) => {
                    console.log('Loading model...', 100.0 * (progress.loaded / progress.total), '%');
                },
                (error) => {
                    console.error(error);
                    document.getElementById('loading').style.display = 'none';
                    const dropMsg = document.getElementById('drop-zone-msg');
                    dropMsg.style.display = 'block';
                    dropMsg.innerHTML = '<div style="font-size: 40px; margin-bottom: 10px;">ğŸ“‚</div>èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼<br>ã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ';
                }
            );
        }

        // --- æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³èª­ã¿è¾¼ã¿ï¼ˆå…¬å¼ã®Mixamoãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½¿ç”¨ï¼‰ ---
        function loadWalkAnimation() {
            if (!currentVrm) return;

            const loader = new FBXLoader();
            
            loader.load(
                CONFIG.walkAnimationUrl,
                (fbx) => {
                    console.log('Walk animation loaded');
                    
                    const clip = fbx.animations[0];
                    if (!clip) {
                        console.error('No animation found in FBX');
                        return;
                    }
                    
                    console.log('Original clip:', clip.name, 'duration:', clip.duration);
                    
                    // â˜… å…¬å¼ã®Mixamoãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–¢æ•°ã‚’ä½¿ç”¨ï¼ˆFBXã‚¢ã‚»ãƒƒãƒˆã‚‚æ¸¡ã™ï¼‰
                    const vrmClip = mixamoVRMRigMap_loadMixamoAnimation(clip, currentVrm, fbx);
                    
                    if (vrmClip) {
                        mixer = new THREE.AnimationMixer(currentVrm.scene);
                        walkAction = mixer.clipAction(vrmClip);
                        walkAction.setLoop(THREE.LoopRepeat);
                        
                        console.log('Walk animation successfully retargeted');
                        
                        // å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚èª­ã¿è¾¼ã‚€
                        loadIdleAnimation();
                    } else {
                        console.error('Failed to retarget animation');
                    }
                },
                (progress) => {
                    console.log('Loading walk animation...', 100.0 * (progress.loaded / progress.total), '%');
                },
                (error) => {
                    console.warn('æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
                }
            );
        }

        // --- å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³èª­ã¿è¾¼ã¿ ---
        function loadIdleAnimation() {
            if (!currentVrm || !mixer) return;

            const loader = new FBXLoader();
            
            loader.load(
                CONFIG.idleAnimationUrl,
                (fbx) => {
                    console.log('Idle animation loaded');
                    
                    const clip = fbx.animations[0];
                    if (!clip) {
                        console.error('No animation found in idle FBX');
                        return;
                    }
                    
                    console.log('Idle clip:', clip.name, 'duration:', clip.duration);
                    
                    // Mixamoãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                    const vrmClip = mixamoVRMRigMap_loadMixamoAnimation(clip, currentVrm, fbx);
                    
                    if (vrmClip) {
                        idleAction = mixer.clipAction(vrmClip);
                        idleAction.setLoop(THREE.LoopRepeat);
                        
                        // åˆæœŸçŠ¶æ…‹ã§å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†ç”Ÿ
                        idleAction.play();
                        currentAction = idleAction;
                        
                        console.log('Idle animation successfully retargeted and playing');
                    } else {
                        console.error('Failed to retarget idle animation');
                    }
                },
                (progress) => {
                    console.log('Loading idle animation...', 100.0 * (progress.loaded / progress.total), '%');
                },
                (error) => {
                    console.warn('å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
                }
            );
        }

        // â˜… å…¬å¼ç‰ˆï¼šMixamoã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆé–¢æ•°ï¼ˆå®Œå…¨ç‰ˆï¼‰
        function mixamoVRMRigMap_loadMixamoAnimation(clip, vrm, asset) {
            const tracks = [];

            const restRotationInverse = new THREE.Quaternion();
            const parentRestWorldRotation = new THREE.Quaternion();
            const _quatA = new THREE.Quaternion();
            const _vec3 = new THREE.Vector3();

            // Hipsã®é«˜ã•ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—
            const motionHipsHeight = asset.getObjectByName('mixamorigHips').position.y;
            const vrmHipsHeight = vrm.humanoid.normalizedRestPose.hips.position[1];
            const hipsPositionScale = vrmHipsHeight / motionHipsHeight;

            clip.tracks.forEach((track) => {
                // ãƒˆãƒ©ãƒƒã‚¯åã‚’åˆ†è§£
                const trackSplitted = track.name.split('.');
                const mixamoRigName = trackSplitted[0];
                const vrmBoneName = mixamoVRMRigMap[mixamoRigName];
                const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
                const mixamoRigNode = asset.getObjectByName(mixamoRigName); // â˜… assetã‹ã‚‰å–å¾—

                if (vrmNodeName != null) {
                    const propertyName = trackSplitted[1];

                    // Rest-poseã®å›è»¢ã‚’ä¿å­˜
                    mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
                    mixamoRigNode.parent.getWorldQuaternion(parentRestWorldRotation);

                    if (track instanceof THREE.QuaternionKeyframeTrack) {
                        // å›è»¢ã®ãƒªã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                        for (let i = 0; i < track.values.length; i += 4) {
                            const flatQuaternion = track.values.slice(i, i + 4);

                            _quatA.fromArray(flatQuaternion);

                            // è¦ªã®ãƒ¬ã‚¹ãƒˆæ™‚ãƒ¯ãƒ¼ãƒ«ãƒ‰å›è»¢ * ãƒˆãƒ©ãƒƒã‚¯ã®å›è»¢ * ãƒ¬ã‚¹ãƒˆæ™‚ãƒ¯ãƒ¼ãƒ«ãƒ‰å›è»¢ã®é€†
                            _quatA
                                .premultiply(parentRestWorldRotation)
                                .multiply(restRotationInverse);

                            _quatA.toArray(flatQuaternion);

                            flatQuaternion.forEach((v, index) => {
                                track.values[index + i] = v;
                            });
                        }

                        tracks.push(
                            new THREE.QuaternionKeyframeTrack(
                                `${vrmNodeName}.${propertyName}`,
                                track.times,
                                track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 2 === 0 ? -v : v)),
                            ),
                        );

                    } else if (track instanceof THREE.VectorKeyframeTrack) {
                        // ä½ç½®ãƒˆãƒ©ãƒƒã‚¯ã«hipsã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
                        const value = track.values.map((v, i) => (vrm.meta?.metaVersion === '0' && i % 3 !== 1 ? -v : v) * hipsPositionScale);
                        tracks.push(new THREE.VectorKeyframeTrack(`${vrmNodeName}.${propertyName}`, track.times, value));
                    }
                }
            });

            console.log(`Created ${tracks.length} animation tracks from ${clip.tracks.length} original tracks`);
            return new THREE.AnimationClip('vrmAnimation', clip.duration, tracks);
        }

        // Mixamo Rig ã‹ã‚‰ VRM Humanoid Bone ã¸ã®å¯¾å¿œãƒãƒƒãƒ—ï¼ˆå®Œå…¨ç‰ˆï¼‰
        const mixamoVRMRigMap = {
            mixamorigHips: 'hips',
            mixamorigSpine: 'spine',
            mixamorigSpine1: 'chest',
            mixamorigSpine2: 'upperChest',
            mixamorigNeck: 'neck',
            mixamorigHead: 'head',
            mixamorigLeftShoulder: 'leftShoulder',
            mixamorigLeftArm: 'leftUpperArm',
            mixamorigLeftForeArm: 'leftLowerArm',
            mixamorigLeftHand: 'leftHand',
            mixamorigLeftHandThumb1: 'leftThumbMetacarpal',
            mixamorigLeftHandThumb2: 'leftThumbProximal',
            mixamorigLeftHandThumb3: 'leftThumbDistal',
            mixamorigLeftHandIndex1: 'leftIndexProximal',
            mixamorigLeftHandIndex2: 'leftIndexIntermediate',
            mixamorigLeftHandIndex3: 'leftIndexDistal',
            mixamorigLeftHandMiddle1: 'leftMiddleProximal',
            mixamorigLeftHandMiddle2: 'leftMiddleIntermediate',
            mixamorigLeftHandMiddle3: 'leftMiddleDistal',
            mixamorigLeftHandRing1: 'leftRingProximal',
            mixamorigLeftHandRing2: 'leftRingIntermediate',
            mixamorigLeftHandRing3: 'leftRingDistal',
            mixamorigLeftHandPinky1: 'leftLittleProximal',
            mixamorigLeftHandPinky2: 'leftLittleIntermediate',
            mixamorigLeftHandPinky3: 'leftLittleDistal',
            mixamorigRightShoulder: 'rightShoulder',
            mixamorigRightArm: 'rightUpperArm',
            mixamorigRightForeArm: 'rightLowerArm',
            mixamorigRightHand: 'rightHand',
            mixamorigRightHandPinky1: 'rightLittleProximal',
            mixamorigRightHandPinky2: 'rightLittleIntermediate',
            mixamorigRightHandPinky3: 'rightLittleDistal',
            mixamorigRightHandRing1: 'rightRingProximal',
            mixamorigRightHandRing2: 'rightRingIntermediate',
            mixamorigRightHandRing3: 'rightRingDistal',
            mixamorigRightHandMiddle1: 'rightMiddleProximal',
            mixamorigRightHandMiddle2: 'rightMiddleIntermediate',
            mixamorigRightHandMiddle3: 'rightMiddleDistal',
            mixamorigRightHandIndex1: 'rightIndexProximal',
            mixamorigRightHandIndex2: 'rightIndexIntermediate',
            mixamorigRightHandIndex3: 'rightIndexDistal',
            mixamorigRightHandThumb1: 'rightThumbMetacarpal',
            mixamorigRightHandThumb2: 'rightThumbProximal',
            mixamorigRightHandThumb3: 'rightThumbDistal',
            mixamorigLeftUpLeg: 'leftUpperLeg',
            mixamorigLeftLeg: 'leftLowerLeg',
            mixamorigLeftFoot: 'leftFoot',
            mixamorigLeftToeBase: 'leftToes',
            mixamorigRightUpLeg: 'rightUpperLeg',
            mixamorigRightLeg: 'rightLowerLeg',
            mixamorigRightFoot: 'rightFoot',
            mixamorigRightToeBase: 'rightToes',
        };

        // --- æ­©è¡Œåˆ¶å¾¡ ---
        function startWandering() {
            if (!currentVrm) return;
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªç›®çš„åœ°ã‚’è¨­å®š
            setRandomDestination();
        }

        function setRandomDestination() {
            if (!currentVrm) return;
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‚’ç”Ÿæˆï¼ˆç¯„å›²å†…ã€å¢ƒç•Œãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
            const maxX = CONFIG.walkAreaSize.x / 2;
            const maxZ = CONFIG.walkAreaSize.z / 2;
            
            targetPosition.set(
                (Math.random() - 0.5) * CONFIG.walkAreaSize.x,
                0,
                (Math.random() - 0.5) * CONFIG.walkAreaSize.z
            );
            
            // å¢ƒç•Œå†…ã«åˆ¶é™
            targetPosition.x = Math.max(-maxX, Math.min(maxX, targetPosition.x));
            targetPosition.z = Math.max(-maxZ, Math.min(maxZ, targetPosition.z));
            
            currentPosition.copy(currentVrm.scene.position);
            
            // ç§»å‹•æ–¹å‘ã‚’è¨ˆç®—
            moveDirection.copy(targetPosition).sub(currentPosition).normalize();
            
            // ç›®æ¨™ã¸ã®å›è»¢è§’åº¦ã‚’è¨ˆç®—
            rotationTarget = Math.atan2(moveDirection.x, moveDirection.z);
            
            // æ­©è¡Œé–‹å§‹
            isWalking = true;
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆï¼šå¾…æ©Ÿ â†’ æ­©è¡Œ
            if (idleAction && idleAction.isRunning()) {
                idleAction.fadeOut(0.3);
            }
            
            if (walkAction) {
                walkAction.reset().fadeIn(0.3).play();
                walkAction.paused = false;
                currentAction = walkAction;
                console.log('Walk animation started');
            }
            
            console.log('Walking to:', targetPosition);
        }

        function stopWalking() {
            isWalking = false;
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆï¼šæ­©è¡Œ â†’ å¾…æ©Ÿ
            if (walkAction && walkAction.isRunning()) {
                walkAction.fadeOut(0.3);
                console.log('Walk animation stopped');
            }
            
            if (idleAction) {
                idleAction.reset().fadeIn(0.3).play();
                currentAction = idleAction;
                console.log('Idle animation started');
            }
            
            // â˜… ã‚«ãƒ¡ãƒ©ã®æ–¹ã‚’å‘ã
            if (currentVrm) {
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                const targetRotation = Math.atan2(cameraDirection.x, cameraDirection.z);
                currentVrm.scene.rotation.y = targetRotation; // ã‚«ãƒ¡ãƒ©ã®æ–¹ã‚’å‘ãï¼ˆ180åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆå‰Šé™¤ï¼‰
            }
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªå¾…æ©Ÿæ™‚é–“å¾Œã«æ¬¡ã®ç›®çš„åœ°ã¸
            const idleTime = CONFIG.idleTimeMin + Math.random() * (CONFIG.idleTimeMax - CONFIG.idleTimeMin);
            setTimeout(setRandomDestination, idleTime);
        }

        function updateWalking(deltaTime) {
            if (!currentVrm || !isWalking) return;
            
            currentPosition.copy(currentVrm.scene.position);
            
            // ç›®çš„åœ°ã¾ã§ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
            const distance = currentPosition.distanceTo(targetPosition);
            
            if (distance < 0.1) {
                // ç›®çš„åœ°ã«åˆ°ç€
                stopWalking();
                return;
            }
            
            // â˜… Root Motionã§ã¯ãªãã€ä¸€å®šé€Ÿåº¦ã§ç§»å‹•
            const step = CONFIG.walkSpeed * deltaTime;
            const nextPosition = currentVrm.scene.position.clone().add(moveDirection.clone().multiplyScalar(step));
            
            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯ï¼ˆç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«ï¼‰
            const maxX = CONFIG.walkAreaSize.x / 2;
            const maxZ = CONFIG.walkAreaSize.z / 2;
            
            nextPosition.x = Math.max(-maxX, Math.min(maxX, nextPosition.x));
            nextPosition.z = Math.max(-maxZ, Math.min(maxZ, nextPosition.z));
            
            // å¢ƒç•Œã«åˆ°é”ã—ãŸå ´åˆã¯æ–°ã—ã„ç›®çš„åœ°ã‚’è¨­å®š
            if (Math.abs(nextPosition.x) >= maxX || Math.abs(nextPosition.z) >= maxZ) {
                stopWalking();
                return;
            }
            
            currentVrm.scene.position.copy(nextPosition);
            
            // å›è»¢ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«ï¼ˆ180åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ï¼‰
            const currentRotation = currentVrm.scene.rotation.y;
            let rotationDiff = (rotationTarget + Math.PI) - currentRotation; // â˜… å‰ã‚’å‘ãã‚ˆã†ã«+180åº¦
            
            // è§’åº¦ã®æ­£è¦åŒ–ï¼ˆ-PI ~ PIï¼‰
            while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
            while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
            
            currentVrm.scene.rotation.y += rotationDiff * 0.1;
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone-msg');
            const fileInput = document.getElementById('file-input');
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) processFile(file);
            });

            window.addEventListener('dragover', (e) => e.preventDefault());
            window.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file) processFile(file);
            });
        }

        function processFile(file) {
            if (!file.name.endsWith('.vrm')) {
                alert('VRMãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ (.vrm)');
                return;
            }
            const url = URL.createObjectURL(file);
            loadVRM(url);
        }

        // --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ & ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (lookAtTarget) {
                lookAtTarget.position.x = mouse.x * 1.0;
                lookAtTarget.position.y = 1.3 + (mouse.y * 0.5); 
                lookAtTarget.position.z = 1.0; 
            }
        }

        function onMouseDown() {
            jump();
        }

        function scheduleBlink() {
            const nextBlinkTime = Math.random() * 2000 + 3000;
            setTimeout(() => {
                blink();
                scheduleBlink();
            }, nextBlinkTime);
        }

        function blink() {
            if (!currentVrm) return;
            
            let blinkVal = 0;
            const duration = 150;
            const startTime = Date.now();

            const interval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                if (elapsed >= duration) {
                    currentVrm.expressionManager.setValue('blink', 0);
                    currentVrm.expressionManager.update(); 
                    clearInterval(interval);
                    return;
                }

                const progress = elapsed / duration;
                blinkVal = Math.sin(progress * Math.PI);
                
                currentVrm.expressionManager.setValue('blink', blinkVal);
                currentVrm.expressionManager.update();
            }, 16);
        }

        function triggerWave() {
            if (!currentVrm || isWaving) return;
            isWaving = true;
            showMessage("ğŸ‘‹");
            
            setTimeout(() => {
                isWaving = false;
                hideMessage();
            }, 3000);
        }

        function jump() {
            if (!currentVrm) return;
            
            const rootBone = currentVrm.scene; 
            if (rootBone.position.y > 0.01) return;

            const jumpDuration = 500;
            const startTime = Date.now();

            const interval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                if (elapsed >= jumpDuration) {
                    rootBone.position.y = 0;
                    clearInterval(interval);
                    return;
                }
                const progress = elapsed / jumpDuration;
                rootBone.position.y = Math.sin(progress * Math.PI) * 0.3;
            }, 16);
            
            currentVrm.expressionManager.setValue('happy', 1.0);
            setTimeout(() => {
                currentVrm.expressionManager.setValue('happy', 0.0);
            }, 1000);
            
            showMessage("ã‚ãƒ¼ã„ï¼");
        }

        function showMessage(text) {
            const msgBox = document.getElementById('message-box');
            msgBox.innerText = text;
            msgBox.style.opacity = 1;
            msgBox.style.top = "10%";
        }

        function hideMessage() {
            const msgBox = document.getElementById('message-box');
            msgBox.style.opacity = 0;
            msgBox.style.top = "15%";
        }

        // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            const time = clock.elapsedTime;

            if (currentVrm) {
                // æ­©è¡Œå‡¦ç†ã®æ›´æ–°
                updateWalking(deltaTime);
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒŸã‚­ã‚µãƒ¼ã®æ›´æ–°ï¼ˆå¸¸ã«æ›´æ–°ï¼‰
                if (mixer) {
                    mixer.update(deltaTime);
                }
                
                // VRMã®æ›´æ–°ï¼ˆæœ€å¾Œã«å®Ÿè¡Œï¼‰
                currentVrm.update(deltaTime);

                // æ‰‹ã‚’æŒ¯ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ­©è¡Œä¸­ã¯ç„¡åŠ¹ï¼‰
                if (isWaving && !isWalking) {
                    const rArm = currentVrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                    const rForeArm = currentVrm.humanoid.getNormalizedBoneNode('rightLowerArm');

                    if (rArm && rForeArm) {
                        const waveSpeed = 10;
                        const waveAngle = Math.sin(time * waveSpeed) * 0.3;

                        const qArm = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 1.2 + waveAngle * 0.1, 'XYZ')); 
                        const qForeArm = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0.5 + waveAngle, 'XYZ'));
                        
                        rArm.rotation.setFromQuaternion(qArm);
                        rForeArm.rotation.setFromQuaternion(qForeArm);
                    }
                }
                // å¾…æ©Ÿä¸­ã¯å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒè‡ªå‹•çš„ã«å†ç”Ÿã•ã‚Œã‚‹
            }

            renderer.render(scene, camera);
        }

        // åˆæœŸåŒ–
        init();

    </script>
</body>
</html>